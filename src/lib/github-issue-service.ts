import { Octokit } from '@octokit/rest';

export interface GitHubIssueResult {
  repoUrl: string;
  success: boolean;
  issueNumber?: number;
  issueUrl?: string;
  error?: string;
}

export interface RepositoryFeedback {
  repoUrl: string;
  repoExplained?: string;
  developerFeedback: string;
}

export class GitHubIssueService {
  private octokit: Octokit;

  constructor(githubToken: string) {
    this.octokit = new Octokit({
      auth: githubToken,
    });
  }

  /**
   * Extracts owner and repo name from a GitHub URL
   */
  private parseGitHubUrl(url: string): { owner: string; repo: string } | null {
    try {
      const urlObj = new URL(url);
      const pathParts = urlObj.pathname.split('/').filter((p) => p);

      if (pathParts.length >= 2) {
        return {
          owner: pathParts[0],
          repo: pathParts[1].replace('.git', ''),
        };
      }
    } catch (error) {
      // Invalid URL
    }
    return null;
  }

  /**
   * Formats the feedback into a GitHub issue body
   */
  private formatIssueBody(feedback: RepositoryFeedback): string {
    let body = '# Homework Feedback\n\n';

    if (feedback.repoExplained) {
      body += '## Repository Overview\n\n';
      body += feedback.repoExplained + '\n\n';
    }

    body += '## Developer Feedback\n\n';
    body += feedback.developerFeedback + '\n\n';

    body += '---\n';
    body += '*This feedback was automatically generated by the homework grading system.*';

    return body;
  }

  /**
   * Creates a GitHub issue with the feedback in the specified repository
   */
  async createIssue(feedback: RepositoryFeedback): Promise<GitHubIssueResult> {
    const parsed = this.parseGitHubUrl(feedback.repoUrl);

    if (!parsed) {
      return {
        repoUrl: feedback.repoUrl,
        success: false,
        error: 'Invalid GitHub URL format',
      };
    }

    try {
      const response = await this.octokit.issues.create({
        owner: parsed.owner,
        repo: parsed.repo,
        title: 'Homework Grading Feedback',
        body: this.formatIssueBody(feedback),
        labels: ['homework-feedback', 'automated'],
      });

      return {
        repoUrl: feedback.repoUrl,
        success: true,
        issueNumber: response.data.number,
        issueUrl: response.data.html_url,
      };
    } catch (error: any) {
      let errorMessage = 'Unknown error occurred';

      if (error.status === 401) {
        errorMessage = 'Authentication failed - invalid GitHub token';
      } else if (error.status === 403) {
        errorMessage = 'Permission denied - token lacks required permissions';
      } else if (error.status === 404) {
        errorMessage = 'Repository not found or no access';
      } else if (error.status === 410) {
        errorMessage = 'Issues are disabled for this repository';
      } else if (error.message) {
        errorMessage = error.message;
      }

      return {
        repoUrl: feedback.repoUrl,
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Creates issues for multiple repositories in parallel
   */
  async createIssuesForBatch(
    feedbacks: RepositoryFeedback[],
    onProgress?: (current: number, total: number) => void,
  ): Promise<GitHubIssueResult[]> {
    const results: GitHubIssueResult[] = [];

    for (let i = 0; i < feedbacks.length; i++) {
      const result = await this.createIssue(feedbacks[i]);
      results.push(result);

      if (onProgress) {
        onProgress(i + 1, feedbacks.length);
      }
    }

    return results;
  }
}
